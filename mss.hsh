# Author: Caio Raposo
# Date: 2022-09-09
# Description: Calculates the maximum subarray sum, and uses memoization to run
# in time complexity O(n) instead of O(nÂ²), where n is the array length. 
# Example: v = [-25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4]
# Solution: v[5..8] = [18, 20, -7, 12]
# Reference: Introduction to Algorithms 3ed, Cormen et al, pages 68 and 387.

let util = std.import("util.hsh")
let args = std.args()

let n = args[0]
let v = util.shuf(1, 30, n)

function max(n, m, o)
	if n >= m and n >= o then
		n
	elseif m >= n and m >= o then
		m
	else
		o
	end
end

memo function mss(i)
	if i == -1 then
		0
	else
		max(mss(i-1), mss(i-1) + v[i], v[i])
	end
end

let table = @[]
function tmss(i)
	if i == -1 then
		0
	elseif std.contains(table, i) then
		table[i]
	else
		table[i] = max(mss(i-1), mss(i-1) + v[i], v[i])
		table[i]
	end
end

for i in std.range(0, n, 1) do
	table = @[]
	let t = util.time_ns()
	let r = mss(i)
	t = (util.time_ns() - t) / 1000000
	{ echo $i,$t,$r }
end
