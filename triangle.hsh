# Author: Caio Raposo
# Date: 2022-09-09
# Description: Given a triangle array, return the *minimum path sum* from top to
# bottom. This implementation runs on O(n) where n is the depth of the triangle.
# Example:
# Input = [[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]
# Output: 11
# Triangle:
#              2
#            3   4
#          6   5   7
#        4   1   8   3
#
# Answer: 2 + 3 + 5 + 1 = 11
#
# Reference: 

let util = std.import("util.hsh")
let args = std.args()

let t = []
let n = args[0]

# Generate triangle with n rows
for i in std.range(1, n, 1) do
	std.push(t, util.shuf(1, 50, n))
end

function min(a, b)
	if a <= b then
		a
	else
		b
	end
end

memo function min_path_sum(i, j, k)
	if i == k - 1 then
		t[i][j]
	else
		min(min_path_sum(i + 1, j, k), min_path_sum(i + 1, j + 1, k)) + t[i][j]
	end
end

let table = @[]
function tmin_path_sum(i, j, k)
	if i == k - 1 then
		t[i][j]
	elseif std.contains(table, [i, j]) then
		table[[i, j]]
	else
		table[[i, j]] = min(min_path_sum(i + 1, j, k), min_path_sum(i + 1, j + 1, k)) + t[i][j]
		table[[i, j]]
	end
end

for i in std.range(1, n, 1) do
	table = @[]
	let t = util.time_ns()
	let r = f(0, 0, i)
	t = (util.time_ns() - t) / 1000000
	{ echo $i,$t,$r }
end
