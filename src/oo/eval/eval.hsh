# Author: Caio Raposo
# Date: 2023-03-23
# Description: This program evaluates arithmetic expressions by modeling
# operators as memoized objects, thus avoiding recalculating past computations.

let args = std.args()

# Number of arthmetic operations
let MAX = std.int(args[0])
let N = std.int(args[1])

let Num = memo function(n)
	@[
		_n: n,

		eval: function()
			self._n
		end
	]
end

let Add = memo function(a, b)
	@[
		_a: a,
		_b: b,

		eval: function()
			self._a.eval() + self._b.eval()
		end
	]
end

let Sub = memo function(a, b)
	@[
		_a: a,
		_b: b,

		eval: function()
			self._a.eval() - self._b.eval()
		end
	]
end

let Mul = memo function(a, b)
	@[
		_a: a,
		_b: b,

		eval: function()
			self._a.eval() * self._b.eval()
		end
	]
end


let Div = memo function(a, b)
	@[
		_a: a,
		_b: b,

		eval: function()
			if self._b.eval() == 0 then
				self._a.eval()
			else
				self._a.eval() / self._b.eval()
			end
		end
	]
end

for _ in std.range(0, N, 1) do
	let n0 = Num(std.randint(0, MAX))
end
